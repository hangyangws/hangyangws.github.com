<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[使用 React Hooks 代替 Redux]]></title>
    <url>%2F2018%2F07%2F27%2Fhooks-replace-redux%2F</url>
    <content type="text"><![CDATA[注：此文章立场不表示 Hooks 可以完全代替 Redux。因为 Redux 还有其他适用的场景和功能，只是在大部分场景可以用 Hooks 代替。理性选择即合理。 React Hooks 面世也有很大一段时间了。我相信很多人对于 Hooks 的认知还大概处在： 更 FP「Functional Programming」 编程方式 更简洁易测的组件 不用记住繁琐的生命周期函数 … 上述这些特征点已经足以说服很大一部分人升级他们的 React 应用。但是总是感觉少了点什么。 我们知道 React 是一个以构建 UI 为主的的库：A JavaScript library for building user interfaces.但是 UI 如果脱离了数据，基本上也就是耍流氓了。所以有 Redux、Mbox… 这样以数据管理为核心的库出现了。现实业务场景中，UI 与数据相辅相成。 在我最初学 React 的时候，原于成熟的方案、同事的推荐，是直接和 Redux 一起学习并且上手开发的。当时我就在想：React 为什么不能自己实现类似 Redux 那样的数据处理功能呢？对于想学习 React 的同学，无疑是增加了 Redux 的学习成本，更加深了 React 的门槛与神秘值「这可不是一个优秀的开源库该有的特质」。 往简单了说 Redux 就是实现了全局 state 、处理全局 state 的方式和统一的数据处理中心，也就是 store、dispatch 和 reducer。虽然在 Hooks 之前我们可以通过 Context 模拟全局 state，但是我们还不能优雅的模拟 dispatch、reducer。 如果 React 官方能出一个数据处理的解决方案，不单单是减少一个 Redux npm 包的 bundle 体积，还降低了学习与构建 React 应用的成本，最重要的是更统一化的数据处理思想。 年前，我在构建一个新的后台管理应用，考虑使用全新的 Hooks API。当时 React 最新的版本还是 16.7.0-alpha.2。 在对于数据处理上，我尝试了新的 React Context API， 使用 Context API 提供的 Provider 和 Consumer 的方法，去实现代替 Redux 的数据处理方案「这也是网上大部分推荐的代替 Redux 的方案」。但是代码越写越多，数据处理量越来越大，数据分类越来越多的时候，Context 显得力不从心，虽然能解决需求，但是代码组织方式已经乱成了一锅粥「尝试过这个方案的人，应该知道我在说什么」。 注：更不要使用 useState + context 的方式创建全局仓库来代替 Redux。 十分万幸的是，不久后 React 更新版本到 16.8.1。 推出了新的 Hooks：useReducer，惊喜之外意料之中。这也就是这篇文章要讲的核心：使用 Hooks：useReducer 代替 Redux。 数据流对比redux hooks 简单分析redux 的数据流程图画得比较简单，理解大概意思就好，毕竟它不是我要说的重点，和 hooks 的数据流程相比其实是大同小异。 从 hooks 数据流能大致看出来，我们设计好 store 后，通过对应的 hooks 函数生成每个 store 的 Provider 和 Context。我们把所有的单个 Provider 糅合为一个整体的 Providers，作为所有 UI 的父组件。 在任何一个子 UI 组件内部，通过 hooks 函数得到对应 store 的 state、dispatch。UI 组件内，通过主动调用 dispatch 发送 action，然后经过 store 的数据处理中心 reducer，就能触发相应的数据改变。这个数据流程和 redux 几乎一模一样。 相同点 统一 store 数据管理 支持以发送 action 来修改数据 支持 action 处理中心：reducer 异同点 hooks UI 层获取 store 和 dispatch 不需要用 HOC 依赖注入，而是用 useContext redux 在 action 之后改变视图本质上还是 state 注入的方式修改的组件内部 state，而 hooks 则是一对一的数据触发 hooks 的 reducer 来自于 useReducer hooks 还没有 middleware 的解决方案 构建应用 DEMO 在构建应用之前，我们应该充分了解我们的应用，了解每一个 API 接口和返回的数据。这样不至于开发中期再来修改我们的仓库设计。需要我们设计一个本地数「全局 store」，和相应的 action 用来修改这些数据。其次就是目录设计了。接下来我们以一个 TO DO Lists 为例开发一个纯 hooks 的 SPA 吧。 本地数据库设计 一个叫 list 的仓库 三个 action: 增「ADD」、删「DELETE」、改「MODIFY」 目录结构 这个目录是比较简单的，毕竟是个 DEMO，和 hooks 无关的没列出来。 index.js 应用入口12345678910111213141516171819...import List from 'Pages/List/index';import Layout from 'Components/Layout/index';import history from './history';ReactDOM.render( &lt;Router history=&#123;history&#125;&gt; &lt;Layout&gt; &lt;Switch&gt; &lt;Redirect exact from="/" to="/List" /&gt; &lt;Route path="/list" component=&#123;List&#125; /&gt; &lt;Route component=&#123;NotFound&#125; /&gt; &lt;/Switch&gt; &lt;/Layout&gt; &lt;/Router&gt;, document.getElementById('container')); components/Layout/index 应用主结构12345678910111213141516...// 引入组合 Providerimport Provider from 'Store/provider';import Header from './components/Header/index';import Footer from './components/Footer/index';const Layout = (props) =&gt; ( &lt;Provider&gt; &lt;Header /&gt; &#123;props.children&#125; &lt;Footer /&gt; &lt;/Provider&gt;);export default Layout; 这里的代码很关键，在 Layout 中我们引入「组合 Provider」，提供「统一仓库数据提供」的能力，让子 UI 组件能获取 store 数据。 store 设计 provider.js12345678910111213...import Lists from './lists/index';const Provider = (props) =&gt; &#123; return ( &lt;Lists.Provider&gt; &#123;props.children&#125; &lt;/Lists.Provider&gt; );&#125;;export default Provider; 仔细观察这里的代码人应该会发现一个问题：在 store 拓展的的情况下，这个代码很可能出现 代码嵌套地狱，类似这样： 12345678910111213141516171819202122...// 多个 store 实例的情况import One from './One/index';import Two from './Two/index';import Three from './Three/index';...const Provider = (props) =&gt; &#123; return ( &lt;One.Provider&gt; &lt;Two.Provider&gt; &lt;Three.Provider&gt; ... &#123;props.children&#125; ... &lt;/Three.Provider&gt; &lt;/Two.Provider&gt; &lt;/One.Provider&gt; );&#125;;export default Provider; 所以需要 provider 组合器。 优化后 provider.js12345678910111213141516171819...import providers from './providers';// 数据 Provider 组合器const ProvidersComposer = (props) =&gt; ( props.providers.reduceRight((children, Parent) =&gt; ( &lt;Parent&gt;&#123;children&#125;&lt;/Parent&gt; ), props.children));const Provider = (props) =&gt; &#123; return ( &lt;ProvidersComposer providers=&#123;providers&#125;&gt; &#123;props.children&#125; &lt;/ProvidersComposer&gt; );&#125;;export default Provider; 上面代码灵感来自：How to combo multiple ContextProvider providers.js12345import Lists from './lists/index';const providers = [Lists.Provider];export default providers; 即使有多个 Provider 我们也可以通过一维数组搞定啦！ 数据项 &amp;&amp; 数据处理器在构建好基本的 Provider 后，我们需要提供基本的数据项和 reducer。 数据项1234567891011121314151617import React, &#123; useReducer &#125; from 'react';import reducer, &#123; initState &#125; from './reducer';const Context = React.createContext();const Provider = (props) =&gt; &#123; const [state, dispatch] = useReducer(reducer, initState); return ( &lt;Context.Provider value=&#123;&#123; state, dispatch &#125;&#125;&gt; &#123;props.children&#125; &lt;/Context.Provider&gt; );&#125;;export default &#123; Context, Provider &#125;; 首先使用 createContext 函数创建好上下 Context，并且对 Context 的 Provider 提供初始化 value，即 state、dispatch。初始化的 state、dispatch 来自于 hooks：useReducer：通过 useReducer 函数传入 reducer、initState，得到这样的数据结构： [state, dispatch]。 不同的数据项的代码完全是通用，差异点在于每个数据项的 reducer、initState 不一样。 reducer12345678910111213141516171819202122export const initState = []; // 默认 todolist 是空数组// 数据处理器const reducer = (state, action) =&gt; &#123; const &#123; type, payload &#125; = action; switch (type) &#123; case 'ADD': return [...state, payload.data]; case 'MODIFY': return state.map( item =&gt; (item.id === payload.id ? payload.data : item); case 'DELETE': return state.map( item =&gt; (item.id === payload.id ? null : item) ).filter(n =&gt; n); default: return state; &#125;&#125;;export default reducer; 能看出来，hooks reduer 和 redux reducer 基本没有区别。我们根据 action 更新 state，还是那么熟悉的味道，那么熟悉的 switch 函数。 UI 组件1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import React from 'react';import StoreLists from 'Store/lists/index';const Lists = () =&gt; &#123; const &#123; state: lists, dispatch: listsDispatch &#125; = React.useContext(StoreLists.Context); const &#123; newList, setNewList &#125; = React.useState(''); handleDelete = item =&gt; () =&gt; &#123; listsDispatch(&#123; type: 'DELETE', payload: item &#125;); &#125;; handleSetNewList = e =&gt; &#123; setNewList(e.value); &#125;; handleNewList = () =&gt; &#123; listsDispatch(&#123; type: 'ADD', payload: &#123; id: Math.random() * 100, name: newList &#125; &#125;); &#125;; return ( &lt;div&gt; &lt;h1&gt;TO DO list 列表&lt;/h1&gt; &lt;ul&gt; &#123;lists.map(item =&gt; ( &lt;li key=&#123;item.id&#125;&gt; &#123;item.name&#125; &lt;button onClick=&#123;handleDelete(item)&#125;&gt;删除&lt;/button&gt; &lt;/li&gt; ))&#125; &lt;/ul&gt; &lt;inpt type="text" value=&#123;newList&#125; onChange=&#123;handleSetNewList&#125; /&gt; &lt;button onChange=&#123;handleNewList&#125;&gt;新建列表&lt;/button&gt; &lt;/div&gt; );&#125;;export default Lists; 在 UI 组件内，使用 hooks：useContext。useContext 接受 store 导出的 Context 作为参数，得到 state、dispatch。使用 state 渲染数据，使用 dispatch 修改数据。 真实代码示例通过上面的目录结构、store 设计、UI 组件三大步骤，我们可以使用 hooks 搭建出和 redux 一样的数据处理流程应用了。如果想进一步了解，可以参考应用：hooks-ts-test。]]></content>
      <tags>
        <tag>JS</tag>
        <tag>Hooks</tag>
        <tag>Redux</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基础工具]]></title>
    <url>%2F2018%2F05%2F27%2FbaseTool%2F</url>
    <content type="text"><![CDATA[工欲善其事，必先利其器。大部分情况下，好的工具是起着辅助的作用。即使缺少了好工具也只是降低了开发效率，比如选择记事本也可以写出优秀的代码。但是，我们都是「懒」且聪明的开发者，我们善于使用优秀的工具，让工具解放劳动力，加大生产力，提高开发效率。这里介绍几个前端基本的且广为使用的相关工具：Git 代码管理、Chrome dev tools、编辑器与 IDE、PS 与 Sketch 切图、Charles 网路代理。 代码调试：dev tools在 N 年前，有款工具叫 Firebug，那时他还很流行。2005 年 Firebug 面世，是 Firefox 中首个可以让 Web 开发者检测「inspect」、编辑「edit」、调试「debug」的工具。在后续的 Firefox Quantum 发布中，Firebug 所有功能已经集成在 Firefox DevTools。 在 2008 年 9 月，Chrome 发布第一版。后来 Chrome dev tools 慢慢占了上风。Firebug 相比 Chrome dev tools 有很多不足，比如：不支持拖拽 DOM、不支持修改修改 user-agent、界面不友好……接下来聊聊 Chrome dev tools，以下简称 devTools「以 Chrome for Mac 67 版本为标准」。 初识 devTools 打开 devTools 界面「快捷键：cmd + ait + I 或者 cmd + shift + C」，看到基本的操作界面，由功能导航栏、功能面板组成。导航栏，主要展示 devTools 主要功能，以及功能切换。最常用的功能面板有：Elements、Console、Network。功能面则是当前使用功能的操作面板。 查找元素、修改样式、事件追踪 首先选择 Element 面板，快捷键「cmd + shift + C」进入选择元素模式，或者点击界面左上角的「元素选择图标」。 鼠标移动到相应的元素上，相应的元素盒子模型会有相应的颜色高亮，用来表示当前选择到的元素的「轮廓」。 选择好对应的元素后，在操作面板会出现 2 个子面板：元素面板、样式面板。并且在元素面板中高亮当前选择的元素，样式面板中展示对应样式和盒子模型。在元素面板中右键元素，会展开很多操作选项，比如复制、删除、编辑节点等选项。在样式面板可以查看、编辑样式，还能查看当前样式所在的 CSS 文件与对应的行数。 在元素样式面板中有「Event Listeners」的一个选项，可以查看当前元素的事件绑定情况，以及对应的 JS 文件、代码。 模拟页面 UserAgent 如果我们需要写 H5 页面，但是又需要模拟手机分辨率的情况，devTools 的 device toolbar 就很有用了。快捷键「cmd + shift + M」或者点击左上角第二个图标，进入 device 调整界面。 查看页面 http 请求 选择 NetWork 面板，可以查看页面所有的 http 请求，且支持搜索、分类查询、查看 http 请求详情等功能。 JS 断点 选择 Sources 面板 → 在左边的资源选择区域选中需要断点的 JS 文件 → 在文件左边的行数提示上点击 → 就完成了一次断点操作。 在开发中，在文件中输入「debugger;」，JS 运行时候会自动在此行断点。在 Sources 面板中，除了可以行断点，还能 XHR 断点。 关于断点，推荐一篇文章：Chrome DevTools — JS调试文章中介绍了 Elements 面板的 DOM 断点、以及 XHR 断点等详细操作。 混淆文件格式化 在 Sources 面板中，混淆文件支持一键格式化。 查看分析页面性能 我们想知道 FPS、CPU、NET 的使用情况；想知道 JS 代码的执行效率；页面 DOM 的渲染情况等都可以从 Performance 面板中查看。 关于性能推荐文章： 前端性能优化之 Performance 神器 总结 devTools 就是一片大海，等着你去航行。短篇幅的入门介绍文章不能全部解读，推荐一篇目录全面，描述详细的好文：Chrome 开发者工具中文文档 Git 代码管理代码管理可是十分的重要，还记得在很久以前使用 SVN，相比后来使用 Git，简直就是解放。与 SVN 相比，Git 具有分布式的特点，使用更灵活，分支轻量化，速度更快，仓库文件尺寸也较小。 在介绍 Git 前，我们得搞清楚 Git 是什么。Git 是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到大小项目的版本管理。Git 是由 Linus 缔造者「Linus Torvalds」为了帮助管理 Linux 内核开发而研发的一个开放源码的版本控制软件。简单来说，Git 就是一个高级的代码历史管理工具，可以手动给代码打标记、记录版本、回滚版本、合并别人的版本…… 这里描述几个平时遇到的业务场景： 修改了两个文件，但是只需要上线其中一个文件的功能，这个时候怎么办？ 两个人在同时维护一个项目，怎么同步对方的代码？ 想看看当前修改代码和上一个版本的区别？ 想回到上一个版本的代码？ 想看看当前项目的文件状态，修改了哪些文件？ 同时开发两个功能，怎样让代码不混在一起？ 一不小心删了代码，不知道怎么退回去？ …… 我相信，如果没有 Git，上面这些问题，真的就是问题了。非常感谢 Linus 大神创造了这么优秀的软件。记得在很久很久以前，我见过复制整个项目文件来做版本管理，现在想想真是令人窒息的操作。可能大家对于版本控制还处于模糊的概念，简单的解释就是，版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。版本控制不区分文件类型，除了 JS、CSS 文件以外图片等任何类型的文件都可以进行版本控制。 Git 的资源有三种状态：已修改「modified」、已暂存「staged」、已提交「committed」。已修改表示修改了文件，但还没保存到数据库中；已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中；已提交表示数据已经安全的保存在本地数据库中。 可以通过「git status」命令查看项目状态。我们可以把本地的 Git 项目分成三个区域概念：工作文件区域、已暂存区域、Git 仓库。结合远端仓库，我们平时的操作流程图大致如下。 Git 是以命令行为基础的软件，但是市面上有这种各样的 GUI 工具，包括狠多 IDE 默认支持 Git 图形界面。建议初次使用者以命令行上手，会让你更快更深的理解 Git，因为很多 GUI 为了降低操作难度，只实现了 Git 部分常用命令。我们可以选择使用 GUI，但是不能不会命令行。 安装 Git 后应该配置一下用户名和邮箱：git config user.name &#39;Name&#39; 修改当前项目用户信息。git config user.email &#39;Name@xx.com&#39; 修改当前项目的邮箱信息。 还有 Git 默认对大小写文件不敏感，需要配置一下：git config core.ignorecase false 让 git 对文件大小写敏感。 在安装、配置好 Git 后，可以选择以 Github 项目作为 Git 实验田。首先第一个使用的命令就是「git clone」。git clone &lt;url&gt; [FolderName]：检出代码到本地；FolderName 为自定义文件夹名，如果不写则默认以项目名新建文件夹。 克隆项目到本地后，默认在 master 分支。比如现在需要开发「登录功能」，首先 checkout 一个新的分支：login。git checkout login 适用于切换到已经存在的分支，比如切换到 master 分支；git checkout -b login 先创建分支，再切换到该分支，适用于开发新功能的时候使用。 在新的 login 分支上，我们开始开发，新建、修改文件等一些列操作。在开发过程中通过 git status 查看文件的状态。功能开发好了后通过 git add 把相关文件添加到暂存区，然后 git commit -m &#39;登录功能&#39; 添加缓冲区文件到「已提交区」记录文件快照。建议每次 git commit 操作的时候都带上简要的消息。 可能还有其他同事一起开发，我们需要同步他们的代码，在代码合并的时候也许会遇到代码冲突。代码冲突是指多人同时修改同一个文件同一个地方，Git 会不知道使用哪个版本，这个会交给开发者自己解决。首先获取新的代码，方式大致有 2 种：git pull、git rebase。这里介绍 git rebase。关于 pull 与 rebase 的区别，这里不深入讨论。同步远端分支的代码一般流程： git fetch // 获取远端最新的代码 git rebase origin/branchName // 合并 branchName 分支的代码 如果有代码冲突： 解决冲突 // 把冲突的代码改好 git add . // 添加相应的修改文件 git rebase --continue // 代码合并继续，冲突解决完成 在合并同事的代码后，我们通过 git push origin login:login -f 命令把本地 login 分支推送到远端 login 分支。「-f」代表强制推送，一般不推荐使用，当通过 rebase 解决冲突后，一定带上「-f」才能推送成功。 在开发过程中，我们可以通过 git diff 查看已修改的详细内容。注意：在 diff 界面，通过快捷键「q」退出。 如果发现 git commit 的提交信息不正确，还可以通过 git commit --amend 命令修改。通过 git log 命令显示你是提交记录。 如果想回到某次提交的代码，可以通过 git reset 命令。例如： git reset --hard HEAD~3 表示回退到 3 次 commit 前的代码。 git reset --soft 495f7482730bcc110308faa1258432ef5cef8cda表示固定回到某一次提交，后面的 hash 值可以通过「git log」查看。 当我们的分支上线后，可能就不会再使用这个分支，可以通过 git push origin :branchName 删除远端分支。通过 git branch -D branchName 删除本地分支。 Git 十分强大，使用场景不仅仅局限于上面提到的，我们在平时开发合作中会遇到各种各样的需求场景。比如合并分支，强制以线上代码合并等等。Git 的很多命令以及参数需要我们自己去探索，多看文档，多实践。 最后推荐一片完善的详细的 Git 教程：Git Book 其他编辑器与 IDE作为一个 coder，编辑器是基础工具，是必须得熟练掌握的，因为它将陪伴你很多年。编辑器相比 IDE 的优点是：界面简洁，安装包小，启动快速，轻便灵活，可扩展；缺点也随之而来，由于快速，体积小，往往不支持编程语言的识别，不包含调试、编辑等。比较常见编辑器有 Sublime Text、Emacs、Vim、Atom… 比如 Sublime 界面简单，单纯是个文本编辑器，从某种层面上看和 windows 的记事本无差异。但是 Sublime 支持各种快捷键、多行编辑、正则多文件搜索、goto anything、Snippets 代码片段、图片预览、自定义配置、丰富的插件……在熟练使用过后，会成为开发利器，爱不释手。Atom 和 Sublime 大部分类似，Atom 界面是本地 HTMl 渲染，性能相比 Sublime 差一些。 有不少 coder 极客偏爱 Emacs、Vim，前段时间看到一个段子：Q：如何得到一个标准的随机字符串？A：让新手退出 Vim。从这个段子可以看出，Vim 好像很难上手的样子，不过 Vim 也有自己迷人的地方：历史悠久、高逼格「可忽略」、跨平台、Mac，Unix，Linux 自带……Emacs 相比 Vim 用户量会少很多，但是却强大狠多，如果有兴趣可以尝试。编辑器最重要的是自己喜欢，习惯，适应，熟悉，切记盲从跟风。 和编辑往往一起被谈及的是 IDE「Integrated Development Environment - 集成开发环境」。IED 从名字就能看出来，不仅仅只有编辑功能，而是一个集成环境。IDE 就像一个成熟的工厂，不仅仅能编辑代码，甚至可以代码运行、断点，有些 IDE 还集合了相应开发语言的 SDK。在 IDE 中，开发者可以根据自己的开发语言、喜好安装相应的插件，帮助自己更好的运行、调试。市面上常见的 IDE 有：JBuilder、Eclipse「市场份额持续下滑」、Intellij IDEA、Visual Studio Code……在前端，见过做多的是 VSCode、其次是 IDEA。而且碰巧，我见使用 IDEA 的前端工程师们大多安装了 Vim 插件。不过 IDEA 的 Web 版目前是收费的。这里谈一谈 VSCode，更友好的 UI 支持，自带 Git 管理、调试工具、扩展程序管理…… 如果编辑器不能满足自己的日常需求，可以考虑进军 IDE，你会发现另一片新天地。 切图切图可不是像名字一样，看起来那么简单。首先我们得知道我们需要什么样的图，尺寸多大，是否有透明背景，需要什么格式，什么格式最合适…… 一般情况下，小图标、有透明背景的图片统一切图为 png 格式。如果图片颜色要求不高，且颜色单一的图可以考虑切图为 png8，因为 png8 的文件大小会小很多。 png8：最多只能展示 256 种颜色，所以 png8 格式更适合颜色比较单一的图像。例如纯色、logo、图标等，因为颜色数量少，所以图片的体积也会更小。 png24：可展示的颜色就远远多于 png8，最多可展示的颜色数量多达 1600 万；所以 png24 所展示的图片颜色会更丰富，图片的清晰度也会更好，图片质量更高，当然图片的大小也会相应增加，所以 png24 的图片比较适合像摄影作品之类颜色比较丰富的图片； 如果图片没有透明像素，且尺寸较大，考虑切图为 jpg 格式。jpg 相对于 png 没有透明通道，文件体积会小很多。 在 PS 里，快捷键 cmd + shift + alt + S 是图片保存为 web 版格式，且有各种存储选项可供挑选。 首先我们讲讲 PS 切图，如下图需要把一盘小龙虾和盘子阴影切下来，用于 Web 图片。 但是我们发现盘子和阴影是 2 个图层。 这个时候我们可以按住 cmd 键，鼠标依次点击 2 个图层，选中后 cmd + G 快捷键把 2 个图层合并为一个组。然后再右键新的分组，选择「快速导出 png」就可以得到我们需要的 2 个合并后的图层了，并且是透明背景的 png。 另外 PS 的切图工具也是切图不错的选择。 用「切片工具」选择好要切的区域后，在导出 Web 格式的时候，会自动选择切图模式： 现在 UI 设计师都不怎么用 PS 设计，好像喜欢 PS 都是喜欢玩摄影的大佬。UI 设计师纷纷使用 sketch 设计视觉稿，所以我们还得学会 sketch 切图才行呀。 sketch 和 PS 类似，都有层叠的概念。在选中某个层，或者某个组后，在软件右下角有个「Make Exportable」按钮。sketch 支持转换切图倍数，切图格式。 Charles 网络代理、抓包Charles 是作为「代理服务器」来完成封包截取的，在使用 Charles 的第一步是将其设置成系统的代理服务器。 Charles 是作为代理服务器来运作的，默认情况下是不能拦截浏览器的 http 请求的，需要在浏览器上设置代理到 Charles 上。这里推荐一款 Chrome 插件：SwitchyOmega「一个代理设置工具」。 比如我们现在有个需求：在线上环境调试 JS 代码。通过 Charles 代理把线上环境的 JS 文件请求替换为本地的 JS 资源。首先查看 Charles http 端口： 然后在 Chrome 中使用 SwitchyOmega 设置代理到 Charles 上。 再设置 Map Remote，指定代理的请求： 这个时候就完成了资源代理设置，刷新浏览器，在 devTools 版本中看到的相应的 http 请求就是经过 Charles 代理后的。 Charles 抓包原理一样。在设置好代理后，打开 Recoring 功能： 抓包一般常用与手机端，因为 PC 端 devTools 可以做到相似的功能。在手机端一样需要设置代理，且保持手机 Wi-Fi 和电脑处于相同的局域网。]]></content>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[for-in 与 for-of]]></title>
    <url>%2F2018%2F02%2F21%2Ffor-in-of%2F</url>
    <content type="text"><![CDATA[for-in 和 for-of 都是迭代一些数据，它们的主要区别是迭代方式的不同。 for-in 迭代对象的 可枚举属性。 注意：是迭代对象的 属性。 比如： 12345678910111213const iterableArray = ['one']iterableArray.__proto__.two = 'two'iterableArray.three = 'three'for(const prop in iterableArray) &#123; console.log(prop)&#125;// 打印结果：// 0// three// two for-of 遍历 可迭代对象 要迭代的数据。注意：是迭代对象的 数据。 比如： 1234567891011const iterableArray = ['one']iterableArray.__proto__.two = 'two'iterableArray.three = 'three'for(const prop of iterableArray) &#123; console.log(prop)&#125;// 打印结果：// one]]></content>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[service worker]]></title>
    <url>%2F2017%2F07%2F27%2FserviceWorker%2F</url>
    <content type="text"><![CDATA[简介 &amp; 背景众所周知「浏览器的的每个每个网页在单进程中执行，而网页中的 JS 的普通运算在单线程中执行」那么 JS 高负荷运算的时候，单线程就吃不消 那么 救世主 来了 Web Worker 独立与当前网页的 JS 单线程，自己独占一个线程Web Worker 可以理解为，网络的苦力工，可以处理繁重的「任务、运算」Web Worker 线程和 JS 线程，二者之间可使用 postMessage 双向通信 一个乘法 DEMO点我 关闭 worker 实例（杀掉线程） 官方推荐是，使用 self.close 进行内部的自动关闭，这样能防止, 意外关闭正在运行的 worker workerObj.terminate(): 在外部终结该 worker self.close(): 在 worker 内部自动终结 作用域全局索引就是 self 和 this ，来获取 worker 自带的方法 注意事项worker 引用的就是 js 文件由于 worker 是独立的线程，他和 main js threading 有很大区别的 worker 访问权限 有 window.navigator 相关属性和方法 只读的 window.location 内容. window.XMLHttpRequest （卧槽… 可以访问这个那就不得了， worker 就可以利用 ajax 来和后台进行通信了） setInterval 相关时间函数 同域限制 worker 在访问时, 只能是在同一 host 下才行. 即, 你的 worker 只能处于指定目录下的 path 中所以：本地调试 file://xxx 的话, 也不能使用 worker 在当前的 worker 加载其他库文件 可以使用 importScripts 来导入（自动缓存文件）importScripts(&#39;example1.js&#39;,&#39;example2.js&#39;) 使用场景根据 worker 独立线程特性，可以把大规模数据并发， I/O 操作都可以交给他总的来说有这些场景 懒加载数据 文本分析 流媒体数据处理 web database 的更新 Service Worker参考链接1参考链接2 概述使用 Service Worker 可以使你的应用先访问本地缓存所以在离线状态时，在没有通过网络接收到更多的数据前，仍可以提供基本的功能体验这称之为 Offline First 它使得开发者可以支持非常好的离线体验，给予开发者完全控制离线数据的能力service worker 是一段运行在浏览器后台进程里的脚本，它独立于当前页面原生 APP 有 Web 通常所不具备的富离线体验、定时的静默更新、消息通知推送……而 Service workers 标准让在 Web 拥有这些功能成为可能 Service workers 由 cache 和 Worker二部分组成不会阻碍当前 js 进程的执行，确保性能第一service worker 函数像一个代理服务器一样，允许你修改请求和响应，用他们的缓存替代它们等等 SW 是基于 HTTPS 的，如果你的网站不是 HTTPS，那么基本上你也别想了 SW这估计造成了一个困难，即，我调试 SW 的时候咋办解决办法也是有的，使用 charles 或者 fildder 完成域名映射即可 serviceWorker 是挂载到 navigator 下的对象 注册失败原因 你没有在 HTTPS 下运行你的程序 service worker 文件的地址没有写对（需要相对于 origin , 而不是 app 的根目录） service worker 注册的 scope 大于他自己的作用域 注意事项 service worker，它工作在 worker context，所以它不能直接操作 DOM ，但是可以通过 postMessage 与页面之间通信，如果需要的话，让页面自己去操作DOM Service worker 是一个可编程的网络代理，允许开发者控制页面上处理的网络请求 在不被使用的时候，会自己终止，而当它再次被用到的时候，会被重新激活 所以你不能依赖于 service worker 的 onfetch 和 onmessage 的处理函数中的全局状态如果你想要保存一些持久化的信息，你可以在 service worker 里使用 IndexedDB API service work 会收到他域下的所有fetch事件，所以注册时，要注意路径 打开浏览器支持（设置后都需要重启浏览器） Firefox Nightly: about:config 设置 dom.serviceWorkers.enabled 的值为 trueChrome Canary: chrome://flags 开启 experimental-web-platform-features (有些特性在Chrome中没有默认开放支持）Opera: opera://flags 开启 ServiceWorker 支持 需要通过HTTPS来访问你的页面代码（安全）[可以通过git pages 测试] localStorage 跟 service worker 的 cache 工作原理很类似，但是它是同步的，所以不允许在 service workers 内使用 IndexedDB 可以在 service worker 内做数据存储 还不能做到完全的离线，比如需要更新数据库的请求 生命周期 要让一个 service worker 在你的网站上生效，你需要先在你的网页中注册它 浏览器会在后台默默启动一个 service worker 的安装过程安装过程中，浏览器会加载并缓存一些静态资源，如果所有的文件被缓存成功，则安装成功，如果有任何文件加载或缓存失败，则安装失败失败后会重新尝试 请求拦截之 fetch 事件sw 内部的 fetch事件可以拦截 sw 作用域下面的所有请求然后我们可以随便发挥，然后使用 event.respondWith 返回请求响应 SW 支持的事件 install activate message fetch sync push 后台进程: SW 就是一个 worker 独立于当前网页进程。网络代理: SW 可以用来代理请求，缓存文件灵活触发: 需要的时候吊起，不需要的时候睡眠（这个是个坑）异步控制: SW 内部使用 promise 来进行控制。 开始使用浏览器的资源、网页的内存有限，再开个 SW（这个很大的），易闪退为减少性能损耗，一般直接在 onload 里注册 SW 12345678910111213if ('serviceWorker' in navigator) &#123; window.addEventListener('load', function() &#123; // 注册（告诉浏览器你的 service worker 脚本在哪里） // 如果某个 service worker 已经被注册过，再次注册浏览器会自动忽略 navigator.serviceWorker.register('/sw.js').then(function(registration) &#123; // 注册成功 console.log('SW作用域：', registration.scope); &#125;).catch(function(err) &#123; // 注册失败 console.log('SW注册失败：', err); &#125;); &#125;);&#125; 一个 DEMO点我 cachelink 查看打开 chrome://inspect/#service-workers 查看当前浏览器中正在注册的 SWchrome://serviceworker-internals 用来查看当前浏览器中所有注册好的 SW 本地 https 简单构建 python 脚本 python 2python -m SimpleHTTPServer 8001python 3python3 -m http.server 8001 浏览器支持点我 使用分析什么时候开启 SW ? window.onload 可靠吗？例如，Google I/O 2016 网络应用在过渡到主屏幕前先显示一个简短的动画。然后发现，在显示动画期间启动 SW 会导致低端移动设备出现卡顿]]></content>
      <tags>
        <tag>JS</tag>
        <tag>worker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[stylelint 搭配 stylelint-order，更随心所欲的编码 CSS]]></title>
    <url>%2F2017%2F06%2F27%2Fstylelint%2F</url>
    <content type="text"><![CDATA[为什么需要校验 CSS 规则对于编程语言进行「语法、书写」校验，能有效「归并」不同开发者的「不同风格」，还能检验出一些语法错误。比如 eslint 就能校验 JS 代码的「鸡肋糟粕」。对于 CSS 而言，不能算是严格意义的「编程语言」，但是在前端体系中却不能小觑。CSS 是以描述为主的「样式表」，如果「描述」得「混乱、没有规则」，对于其他开发者一定是一个「定时炸弹 💣『特别是有强迫症的人群 😊』」CSS 看似简单，想要写出漂亮的 CSS 还是相当困难。CSS 为什么这么难学？ - CSS 不是科学，而是艺术所以校验 CSS 规则的行动迫在眉睫，立即执行。 团队协作在 CSS 书写遇到的问题请看以下场景： 小冯：你的 CSS 为什么不把 0.1 写成 .1小杰：CSS 解析器一样能识别，不好较真好么小冯：好吧 😨，那为什么你的逗号后面没有空格，我看着很难受啊小杰：我看着不难受就好小冯：😨😨😨，那你能不能不要新建一个空的 CSS 文件啊！！！… 不论是在社区、MR、平时交流中，相似的场景层出不穷，这就是因为 CSS 规则不统一，导致的弊端「冰山一角」 CSS 哪些东西需要校验单纯从代码层面来说，CSS 校验的东西其实蛮少的。比如：属性顺序、小于 1 的小数要不要去掉 0、选择器之间要不要加空格…不过要细细的追究，校验的东西还是挺多的，比如 List of rules 列出了好多需要校验的规则。 叮叮叮~，有个东西要说一下，CSS 语言本身对「规则」不敏感，几乎是你想怎么写就怎么写，只要合乎「语法」。 怎么校验 CSS 规则首先得有一个规则，其次开发者得遵守规则。如何遵守： 提交 「Merge Request」的时候，以「Code Review」的形式「人工校验」。「好蠢啊，费时费力，效果差」 git commit 的时候「自动校验」，校验通过才能提交成功「(＾－＾)V 真好~」 通过 stylelint 校验 CSS 规则简单步骤 安装 stylelint、stylelint-order、stylelint-config-standard npm i --save-dev stylelint stylelint-order stylelint-config-standard 增加 stylelint 配置文件 项目根目录添加文件 .stylelintrc 基本配置文件： 12345&#123; "extends": "stylelint-config-standard", "plugins": [], "rules": &#123;&#125;&#125; 具体的配置文件内容，欢迎参考：点我呀注：配置文件使用的 CSS 属性排序规则来自 这里 在 package.json 的 scripts 字段中添加相关命令 12345&#123; "scripts": &#123; "lint-css": "stylelint 'src/**/*.css' --fix", &#125;&#125; 这样就可以手动执行 npm run lint-css 校验 CSS 了。&#39;src/**/*.css&#39; 以 glob 语法表示 CSS 文件的路径。--fix 表示让 stylelint 尽可能的自动修复 CSS 代码「部分规则还是需要抛出错误，开发者手动修复」 安装 lint-staged、husky npm i --save-dev lint-staged husky 增加 lint-staged 配置文件 项目根目录添加文件 .lintstagedrc 基本配置文件： 123456&#123; "src/**/*.css": [ "stylelint --fix", "git add" ]&#125; 这样就会在执行 git commit 之前会自动以 stylelint --fix 的方式校验 src/**/*.css CSS 文件 stylelint 的更多使用方式stylelint 不仅仅可以用于项目中，还可以用于编辑器，比如「Sublime Text」，详细使用规则，这里不赘述。 移步阅读 写在最后虽然有各种各样的工具能「辅佐」开发者工作，注意，是「辅佐」不是「帮助」。因为开发者自己需要明确「为什么」要这样校验，我们不能被工具「牵着鼻子走」，是我们「命令」工具这样校验。嗯，这点很重要。不然别人问这样做的好处，千万不要「一脸茫然」。 ·感谢阅读·]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>stylelint</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我遇见的哪些 CSS 中有趣的尺寸、宽高]]></title>
    <url>%2F2017%2F06%2F02%2Fcss-width-about%2F</url>
    <content type="text"><![CDATA[写在前面目的：「攻巩固 CSS 知识，发现新的『桃花源』」受众群体：「web 前端开发者、爱好者」 感谢： www.w3.org 文献 张鑫旭 个人博客 不常见长度单位 ex 相对于「小写字母」x 的 高度 ch 相对于「数字」 0 的 宽度 利用 ch 单位实现「打字效果」的 一个 Demo核心原理：利用宽度 ch 刚好是一个字母的宽度实现「宽度等比增长」 vw 相对于视窗的 宽度：视窗宽度是 100vw「window.innerWidth」 vh 相对于视窗的 高度：视窗高度是 100vh「window.innerHeight」 vm 取决于 min(vw, vm) 利用 vw 实现的一个「懒加载时，页面不随着滚动条抖动」的 一个 Dome温馨提示：mac 的浏览器滚动条不占「显示区域」的宽度核心原理：利用宽度 calc(100vm - 100%) 刚好等于滚动条的宽度 实用的实体单位 &amp;emsp; 相当于 em 的宽度 &amp;ensp; 相当于 1/2 em 的宽度 使用场景 当我们需要给文字增加间隙的时候，可能会使用 last-letter，但是他会使最后一个字符后面也有间距所以可以使用 string.split(&#39;&#39;).join(&#39;&amp;ensp;&#39;) 的方式 利用 &amp;emsp; 实现的对齐效果 一个 Demo 另外 text-align: justify; 也能实现「文本两端对齐」的效果 一个 Demo height、width、百分比、循环先抛出一个疑问：如果没有显示的设置父元素宽高，子元素宽高的百分比有效果吗？看一个 Demo 为什么父元素没有显示得设置高度，子元素高度设置 100% 就没有效果呢？在翻阅 w3 对高度的定义 、w3 对宽度的定义，后了解到浏览器的宽高计算原理： 高度的计算 如果元素 没有显示的设置高度 且 非 fixed/absolute 定位，其 渲染高度 为子元素的的高度，其 计算高度 为 auto所以如果未显示设置父元素高度，其高为 auto，子元素 height: 100% 的意思就是 auto * 100% ≈ auto 宽度的计算 如果元素 没有显示的设置宽度 且 非 fixed/absolute 定位，如果元素是块级元素，其 渲染宽度 为父元素的的宽度，其 计算宽度 也为父元素的的宽度如果元素是行级元素，其 渲染宽度 为子元素的的宽度，其 计算宽度 也为子元素的的宽度所以未显示设置宽度，其高为和 渲染高度 一样，所以子元素的百分比宽度有效果 再抛出一个疑问：这个 Demo 的父元素的宽为什么不是子元素的宽度和？如果父元素宽度变化，这样会不会带来渲染循环问题？ 答案是不会，让我来讲解一下浏览器渲染的基本顺序和原理： 下载文档内容，生成 DOM 加载头部的样式资源，生成 CSSOM 按照从上而下，自外而内的顺序渲染 DOM 内容「先渲染父元素，后渲染子元素」 遵循上面的原则，当浏览器渲染父元素的时候，还未渲染子元素，这个时候浏览器要根据子元素的宽度来计算父元素的宽度，不过这个时候，子元素 DOM 还没有结合 CSSOM 渲染，所以子元素就是图片和文字的宽度和，所以父元素的宽度就是图片和文字的宽度和 所以我们也明白了： CSS 中父元素选择器 久久未实现的原因，是因为这样真的会导致「循环渲染」 padding 百分比抛出一个问题：padding-top、padding-bottom 如果设置为百分比，是相对于什么来计算的？答案是相对于父元素的宽度来计算的「一脸吃惊的表情，记住就好」😑 height:100% 和 height:inherit 的异同如果 height:inherit 是继承父元素的高度，那么和 height:100% 不是没有什么区别么？一般情况他们二者没有区别，区别在于元素为「绝对定位」时绝对定位元素的 height:inherit 是相对于父元素计算；而 height:100% 相对于定位基准元素计算 width 新鲜值作用：在原有的 display 水平不变的情况下拥有元素其他 display 值才有的特性 fill-available fill-available 元素会充分利用可用空间，就像 div 一样「默认 100% 宽度」。块级元素默认宽度表现行为就是 fill-available。一个 Demo 认识 fill-available max-content 假设 我们的容器有足够的宽度，足够的空间，此时，所占据的宽度是就是 max-content 所表示的尺寸一个 Demo 认识 max-content一个 max-content 的实际用例 min-content min-content 元素宽度为「内部元素最小宽度值最大的那个元素的宽度」最小宽度值的意思：例如图片的最小宽度值就是图片呈现的宽度；对于文本元素，如果全部是中文，则最小宽度值就是一个中文的宽度值；如果包含英文，因为默认英文单词不换行，所以，最小宽度可能就是里面最长的英文单词的宽度。 fit-content fit-content 元素的宽度计算方式和「float、absolute、inline-block」一样这种计算方式被称为「shrink-to-fit」 举例一个使用场景，就拿水平居中效果举例：inline-block 元素需要父级使用 text-align: center，而本身可能还需要 text-align: left。😨 mdzz~而 width: fit-content 可以没有这些烦恼，因为，width: fit-content 可以实现元素收缩效果的同时，保持原本的 block 水平状态于是，就可以直接使用 margin: 0 auto 实现元素向内自适应同时的居中效果了]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「移动设备陀螺仪」与「preserve-3d」碰撞的火花]]></title>
    <url>%2F2017%2F05%2F26%2Fpreserve-3d%2F</url>
    <content type="text"><![CDATA[涉及知识「CSS：transform、JS：deviceorientation」 废话不多，先上 DEMO「请使用移动设备查看」 如何搭建一个简单的立方体只需要寥寥几行 HTML、CSS 代码就能产出一个「立方体」 核心 HTML 如下 12345678910111213141516171819202122&lt;div class="cube"&gt; &lt;span class="cube-face cube-front"&gt;&lt;/span&gt; &lt;span class="cube-face cube-back"&gt;&lt;/span&gt; &lt;span class="cube-face cube-left"&gt;&lt;/span&gt; &lt;span class="cube-face cube-right"&gt;&lt;/span&gt; &lt;span class="cube-face cube-top"&gt;&lt;/span&gt; &lt;span class="cube-face cube-bottom"&gt;&lt;/span&gt;&lt;/div&gt;&lt;!-- 6 个 &lt;span /&gt; 表示立方体的 6 个面 --&gt;&lt;!-- 这里有个小插曲： 起初，我使用的 6 个 &lt;i /&gt; 标签，因为大部分表示「图形、图标」的元素都用 &lt;i /&gt; 标签， 不过，强迫症的我，细细想来，&lt;i /&gt; 是表示的「斜体文字」，语义上完全不匹配啊。 所以，我在知乎上搜到这样一个描述：[为什么大家都用i标签&lt;i&gt;&lt;/i&gt;用作小图标?](https://www.zhihu.com/question/26880548) 有个回答： 「 大家都遵循开放的标准来做事，未来可能少走弯路。 少用 hack 的方法解决问题，有助于你写出向未来兼容的代码。 」 我很赞同，所以就把 &lt;i /&gt; 改成了 &lt;span /&gt;。 --&gt; CSS 第一步 1234567891011121314151617181920.cube &#123; width: 160px; height: 160px; position: relative; -webkit-transform-style: preserve-3d; /* 这一句重点 */ transform-style: preserve-3d; -webkit-transform: rotateX(10deg) rotateY(10deg) rotateZ(10deg); transform: rotateX(10deg) rotateY(10deg) rotateZ(10deg);&#125;.cube-face &#123; display: block; position: absolute; width: 100%; height: 100%; box-shadow: inset 0 0 4px 1px #fff; box-sizing: border-box; background: -webkit-linear-gradient(45deg, rgba(156, 144, 144, .6), #000); background: -o-linear-gradient(45deg, rgba(156, 144, 144, .6), #000); background: linear-gradient(45deg, rgba(156, 144, 144, .6), #000)&#125; 这个 CSS 过于简单，就不赘述与解释。主要是要设置父元素 .cube 的 transform-style: preserve-3d， 使子元素位于 3D 空间中，不然子元素都是「平面内、扁平化」，达不到 3D 效果。 给所有子元素 .cube-face 设置了透明的渐变色 rgba(156, 144, 144, .6) 背景，是为了更好的观察到「被遮住的反面」，视觉上更加 立体 目前效果截图大概是这个样子： 看起来就像一个正方形，其实是 6 个面全部重叠在一起。 CSS 第二步 1234.cube-front &#123; -webkit-transform: translateZ(80px); transform: translateZ(80px);&#125; 上面 4 行代码使得「正面 .cube-front」向前移动 80px「也就是立方体一半的边长」。同理我们可以设置「背面 .cube-back」向后移动 80px效果大概是这样： CSS 第三步 1234.cube-left &#123; -webkit-transform: rotateY(90deg); transform: rotateY(90deg);&#125; 上面 4 行代码使得「左面 .cube-left」先顺时针旋转「90 度」大概是这个样子： 然后再向「左边」移动 80px 就 OK 啦，注意：左边是 Z 轴负方向。 1234.cube-left &#123; -webkit-transform: rotateY(90deg) translateZ(-80px); transform: rotateY(90deg) translateZ(-80px);&#125; 大概是这个样子： 同理，我们可以做出右边的效果，唯一区别就是，右边移动方向与左边相反。道理类似，异曲同工，上边和下边，想必聪明的大家都掌握了正确写法姿势。 成品大概是这个样子： 用陀螺仪使立方体动起来细心的开发者应该发现了，在最开始，我给父元素 .cube 设置了：transform: rotateX(10deg) rotateY(10deg) rotateZ(10deg)让父元素在三维空间上旋转 10 度。如果我们动态连续修改这三个值，绝对可以达到 3D 旋转动画的效果。 这个时候，JS 的 deviceorientation「检测设备方向」 事件闪现突然闪现在我的脑海。因为这个事件的回调参数里面恰好有三个参数「beta、gamma、alpha」，分别代表「X、Y、Z」的旋转方向。 beta 表示设备在 x 轴上的旋转角度，范围为 [-180, 180] 度。它描述的是设备由前向后旋转的情况。gamma 表示设备在 y 轴上的旋转角度，范围为 [-90, 90] 度。它描述的是设备由左向右旋转的情况。alpha 表示设备沿 z 轴上的旋转角度，范围为 [0, 360] 度。 大概是这个样子： 注册 deviceorientation 事件，得到 x、y、z 1234567const handleOrientation = (&#123;beta: x, gamma: y, alpha: z&#125;) =&gt; &#123; // 1. 得到 x、y、z // 2. 处理 x、y、z // 3. 使用 x、y、z&#125;global.addEventListener('deviceorientation', handleOrientation) 处理 x、y、z 由于我们期望立方体可以在 x、y、z 三个反向的旋转范围是 [-360, 360] 度，但是 beta、gamma、alpha 的范围并不是我们期望的范围，所以我们要处理一下数据。 12345&#123; x: x * 2, y: y * 4, z: (z - 180) * 2&#125; 使用 x、y、z 我们现在得到的 x、y、z 已经在 [-360, 360] 度范围内了，接下来要做的就是，使用 x、y、z 修改父元素 .cube 的 rotateX(xdeg) rotateY(ydeg) rotateZ(zdeg) 旋转值。 完整的代码大概是这样： 12345678910111213const cube = document.querySelector('.cube')const setCubePosition = (&#123;x = 0, y = 0, z = 0&#125;) =&gt; &#123; cube.style = `transform: rotateX($&#123;x&#125;deg) rotateY($&#123;y&#125;deg) rotateZ($&#123;x&#125;deg);-webkit-transform: rotateX($&#123;x&#125;deg) rotateY($&#123;y&#125;deg) rotateZ($&#123;x&#125;deg);`&#125;const handleOrientation = (&#123;beta: x, gamma: y, alpha: z&#125;) =&gt; &#123; setCubePosition(&#123; x: x * 2, y: y * 4, z: (z - 180) * 2 &#125;)&#125;global.addEventListener('deviceorientation', handleOrientation) 庆祝时刻现在我们已经完成了，一个利用「移动设备陀螺仪」与「preserve-3d」实现的 3D 交互效果。让我们为自己鼓掌 👏👏👏 点我查看完整代码 感谢阅读]]></content>
      <tags>
        <tag>CSS</tag>
        <tag>动画</tag>
        <tag>3D</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVG 扬帆起航]]></title>
    <url>%2F2017%2F04%2F27%2Fsvg%2F</url>
    <content type="text"><![CDATA[本文不能让你成为 SVG 大神，但是能让你知道、了解他「揭开神秘面纱」 基础认知SVG「Scalable Vector Graphics」表示「可缩放矢量图形『放大不模糊』」面向未来「W3C 标准」。基本的 SVG 文档由 &lt;svg&gt; 根元素和 基本形状元素 构成作为 XML 的一种方言，SVG 必须正确的绑定命名空间（在 xmlns 属性中绑定）。命名空间速成 获取更多信息SVG 文件全局有效的规则是 「后来居上」，越后面的元素越可见。 能做什么动画、图形、渐变、旋转、滤镜、JavaScript 接口、各种超酷的动画… 和 HTML 使用的几种方式&lt;img src=&quot;xxx.svg&quot; height=&quot;10&quot; width=&quot;10&quot; /&gt;不能使用JS来控制 .svg { background-image: url(xxx.svg);}最好不使用 base64 格式化 SVG「阻塞其它资源」、不能使用 JS 控制 &lt;iframe src=&quot;xxx.svg&quot;&gt;Not support iframe&lt;/iframe&gt; &lt;embed type=&quot;image/svg+xml&quot; src=&quot;xxx.svg&quot; /&gt; &lt;object type=&quot;image/svg+xml&quot; data=&quot;xxx.svg&quot;&gt;Not support SVG&lt;/object&gt;能使用JS来控制「推荐方式」 &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 10 10&quot;&gt;…&lt;/svg&gt;节省 HTTP 请求，能使用 JS 控制，不能被浏览器缓存 坐标系统看图说话「原点在左上角」： viewBox123&lt;svg width="400" height="300" viewBox="0,0,40,30" style="border:1px solid #cd0000;"&gt; &lt;rect x="10" y="5" width="20" height="15" fill="#cd0000"/&gt;&lt;/svg&gt; viewBox demo 动画理解： 深度阅读 - viewBox CSS、JS 与 SVG内敛样式12345678&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 68 65"&gt; &lt;style type="text/css"&gt; &lt;![CDATA[ .red &#123; strock: #f00; &#125; ]]&gt; &lt;/style&gt; &lt;path class="red" d="M10 10v20" /&gt;&lt;/svg&gt; 外链样式1234&lt;?xml-stylesheet type="text/css" href="xxx.css"?&gt;&lt;svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 68 65"&gt; &lt;path class="cls" d="M42 27v-20" /&gt;&lt;/svg&gt; JS 操作 SVG如果 SVG 代码作为 DOM 在 HTML 内部，可以向平常一样操作 DOM 操作 SVG如果是使用 &lt;object&gt; 你可以使用 contentDocument 来控制它 SVG 注意 &lt;img&gt;、background-image 形式的 SVG 不支持「外链 CSS、JS」 内敛 CSS 和 JS 最好放在 &lt;![CDATA[ 与 ]]&gt; 之中 SVG 基础元素 &lt;svg&gt;：SVG 的根元素，可以相互嵌套 &lt;g&gt;：将 SVG 中的元素进行分组操作，分组后可以看成一个单独的形状，统一转换 &lt;defs&gt;：用于定义在 SVG 中可重用的元素，def 元素不会直接展示出来，可以通过 use 元素来引用 &lt;use&gt;：通过它来复用 def 元素，也包括 &lt;g&gt;、&lt;symbol&gt; 元素，使用 &lt;use xlink:href=&quot;#id&quot;/&gt; 调用 &lt;text&gt;：文本节点，可以实现 word 中的那种「艺术字」 &lt;image&gt;：在 SVG 中嵌套图片，可以对图片做对应的处理 … SVG 形状元素来张图压压惊： 点我查看 SVG 元素的基本 DEMO &lt;path /&gt;别说话，先举个 🌰 ，一起感受一下 path：点我 基于 path 的不同属性，可以画出各种各样的路径，所以 path 可算是 SVG 的「节点之王」除了 path 之外的节点都「比较普通」，可以看成是对 path 的封装，比如「Rect、Circle…」 命令命令都用一个关键字母来表示，命令 都有两种 表示方式 大写字母，表示采用「绝对定位」 小写字母，表示采用「相对定位『相对于上一个点』」 path 的命令列表 document.getElementById(‘path’).getTotalLength() 得到路径长度 M：moveto 移动到 L：lineto 画线到；H：horizontal lineto 水平线到；V：vertical lineto 垂直线到 L 命令将会在当前位置和新位置之间画一条线段：L x y (or l dx dy)还有两个简写命令：H，绘制平行线。V，绘制垂直线。这两个命令都只带一个参数，标明在 x 或 y 轴移动到的位置：H x (or h dx) 、V y (or v dy) Z：closepath 关闭路径 Z 命令会从当前点画一条直线到路径的起点，所以它还是经常被放到路径的最后。另外，Z 命令不用区分大小写：Z (or z) C：curveto 三次贝塞尔曲线 C x1 y1, x2 y2, x y 或 c dx1 dy1, dx2 dy2, dx dy(x1, y1)、(x2, y2) 分别是起点、终点控制点。最后一个坐标 (x, y)，表示曲线的终点三次贝塞尔曲线 表现形式 是：曲线沿着 起点开始 到第一控制点的方向伸出，逐渐弯曲，然后沿着第二控制点到 终点的方向结束 S：smooth curveto 光滑三次贝塞尔曲线 S 命令可以用来创建与之前那些曲线一样的贝塞尔曲线，通常和 C 命令一起使用如果 S 命令跟在一个 C 命令或者另一个 S 命令的后面，它的第一个控制点，就会被假设成前一个控制点的对称点，不应该写出来，所以 S 省略了一个对称点 Q：quadratic Belzier curve 二次贝塞尔曲线 Q x1 y1, x y 或 q dx1 dy1, dx dy T：smooth quadratic Belzier curveto 光滑二次贝塞尔曲线 T x y 或 t dx dyT 命令类似于 S 命令，用于二次贝塞尔曲线。T 命令前面最好是一个 Q 命令，或者是另一个 T 命令如果 T 单独使用，那么控制点就会被认为和终点是同一个点，所以画出来的将是一条直线 A：elliptical Arc 椭圆弧 A rx ry x-axis-rotation large-arc-flag sweep-flag x y 或 a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy rx ry：「椭圆」的 x，y半径x-axis-rotation：X 轴旋转角度，顺时针为正数large-arc-flag：1 表示用大弧度，0 表示小弧度sweep-flag：弧度回话方向，1 顺时针，0 逆时针x y：弧度终点 元素与样式 stroke fill transform linearGradient mask filter clipPath 一些 Demo：svg 模糊 demosymbol demosymbol-use-demotext mask demomask democlip demoSVG 文字路径动画linearGradient Demo 使用 CSS 请注意把 background-color、border 改成 fill 和 stroke上色和填充的部分一般是可以用 CSS 来设置的，比如 fill，stroke，stroke-dasharray，但不包括渐变和图案等。另外，width、height，以及路径的命令等等，都不能用 css 设置不是所有的属性都能用 CSS 来设置：SVG 规范 将属性区分成 properties 和 attributes，前者是可以用 CSS 设置的，后者不能 SVG 动画 SVG 动画 集合SVG 的动画元素是和 SMIL Synchronized Multimedia Integration Language开发组合作开发的。SMIL 开发组和 SVG 开发组合作开发了 SMIL 动画规范，在规范中制定了一个基本的 XML 动画特征集合。SVG 吸收了 SMIL 动画规范当中的动画优点，并提供了一些SVG继承实现。 大概三种实现方式： JS 动画「DOM 操作『忽视它』」 CSS3 动画「animation、transition『不是 svg 的重点』」 SVG 本身的动画「基于 SMIL」「主要借助 SVG animate 相关标签」 setset 表示此元素没有动画效果 😨😨😨。好吧：这样的，虽然 set 虽然不能触发连续的动画，但是，其还是可以实现基本的延迟功能。就是指：可以在特定时间之后修改某个属性值「也可以是 CSS 属性值」。 一个 Demo animateSVG animation 最强大的地方在于：「只要在页面放几个 animate 元素，没有任何 CSS, 没有任何JS」 1234567891011121314&lt;animate id="id" begin="id.end + 1s" attributeName="r" attributeType="XML" from="50" to="80" by="30" values="50;80" begin="0s" dur=".5s" repeatCount="indefinite" fill="freeze"&gt;&lt;/animate&gt; 一个 Demo animateColor一看就知道是颜色动画。不过，animate 可以实现其功能与效果，因此，此属性已经被废弃。可谓因为兄弟相争而年少陨落的天王。逝者已矣，过去的就让它过去吧 1234567891011121314151617181920### animateTransform```xml&lt;animateTransform attributeName=&quot;transform&quot; attributeType=&quot;XML&quot; type=&quot;rotate&quot; from=&quot;0 125 135&quot; to=&quot;360 125 135&quot; begin=&quot;0s&quot; dur=&quot;10s&quot; repeatCount=&quot;indefinite&quot;&gt;&lt;/animateTransform&gt;```[一个 Demo](https://jsfiddle.net/hangyangws/zqLorfo9/1/)### animateMotionanimateMotion 元素可以让 SVG 各种图形沿着特定的 path 路径运动 12345&lt;animateMotion dur="6s" repeatCount="indefinite" path="M100 100, A120 120, -45 0 1, 300 300 A120 120, -45 0 1, 100 100"&gt;&lt;/animateMotion&gt; 一个 Demo 例子分析组合：一个 Demo end 事件：一个 Demo click 事件：一个 Demo 进阶阅读推荐 贝塞尔曲线原理「简单阐述」 工具推荐 svgo 项目地址：点我查看比较厉害的压缩优化 SVG 的工具，可以将 SVG 中的无用信息删掉，同时支持代码进行压缩 SVGOMG 展示地址：SVGOMG - SVGO’s Missing GUISVGOMG 是 svgo 的可视化界面工具，操作起来很方便，还提供了一些其他有用的功能 Snap.svg 项目地址：Snap.svg - HomeSnap.svg 是一个可以使你操纵 SVG 资源和 jQuery 操作 DOM 一样简单的类库，可以写出更加复杂的 SVG 效果，同时文档超级齐全，推荐给想深入了解的同学。]]></content>
      <tags>
        <tag>HTML</tag>
        <tag>SVG</tag>
        <tag>图形</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简谈 Promise]]></title>
    <url>%2F2017%2F01%2F27%2Fpromise%2F</url>
    <content type="text"><![CDATA[参考链接：JavaScript Promise：简介 Promise 是一个解决异步操作的对象。常见的的异步实现方案，就是「回调」。回调是很好的异步解决方案，不过「嵌套多了」就惹得心烦，且代码难以阅读，不直观。Promise 并非解决具体问题的算法，而已代码组织更好的模式。我们也可以实现类似 Promise 的结构，比如 jQuery 的 ajax 「$.ajax」。 一个简单的例子1234567891011121314151617181920212223242526272829303132333435// 注意：// 为什么要用函数把「 new Promise 」包起来，因为 new Promise 时，也会执行函数内部代码// 所以通常用一个函数把「new Promise」包起来，在函数内部 return Promise 的实例// 用 Promise 实现图片异步加载const imageLoad = url =&gt; new Promise((resolve, reject) =&gt; &#123; const image = new Image() image.onload = function() &#123; // 如果图片加载成功调用 resolve 方法 resolve('加载成功') &#125; image.onerror = function() &#123; reject(new Error('加载失败')) &#125; image.src = url&#125;)// 执行 imageLoad 方法，会返回一个 Promise 实例imageLoad('https://avatars3.githubusercontent.com/u/9067839?s=460&amp;v=4') .then( // 加载成功调用的方法 success =&gt; console.log(success), // 加载失败时调用的方法 error =&gt; console.log(error) )// 仔细观察上面的代码，开发者会发现// 创建 Promise 实例时传入函数的第一个参数指向的就是「Promise 实例的 then 方法的第一个参数」// 同理，// 创建 Promise 实例时传入函数的第二个参数指向的就是「Promise 实例的 then 方法的第二个参数」// 所以，// resolve 函数执行时等同执行 then 方法第一个函数参数； reject 函数执行时等同执行 then 方法第二个函数参数 认真看了上面的典型的简单的 Promise 例子，开发者应该对 Promise 不陌生了，至少对 then 方法不陌 😆下面，进一步揭开 Promise 的面纱 Promise 实例的状态每个 Promise 实例都有一个状态，初始为 Pendingresolve 方法可以将 Pending 改为 Resolvedreject 方法可以将 Pending 改为 Rejected注意：没有其他方式可以修改 Promise 实例的状态，且状态不可逆 Promise 原型链方法 原型链方法又称实例方法 Promise.prototype.then() then 方法接受2个函数参数，第一个函数参数将状态变为 Resolved，调用第二个函数参数将状态变为 Rejected then 方法内部 return 详解：如果 then 方法内部 return 的不是一个 Promise 对象那么 return 的值将作为下一个 then 的形参如果没有 return 语句，等同于 return undefined如果 then 方法内部 return 是一个 Promise对象，那么下一个 then 的形参就是这个 Promise 对象执行方法的实参文字有点绕，不是很好理解，请看看如下代码 12345678910111213141516171819202122232425262728function newPromise() &#123; return new Promise(resolve =&gt; resolve('I was resolved'))&#125;new Promise(resolve =&gt; &#123; resolve() &#125;) .then(() =&gt; &#123; // return 一个字符串 return '我只是一个字符串' &#125;) .then(_data =&gt; &#123; console.log(_data) // 打印：'我只是一个字符串' // 没有显式的 return 语句 &#125;) .then(_data =&gt; &#123; console.log(_data) // 打印：undefined // return 一个 Promise 实例 return newPromise() &#125;) .then(_data =&gt; &#123; console.log(_data) // 打印：I was resolved &#125;)// 观察上面的代码// 发现， then 内部无论返回什么都可以链式调用// 证明， then 执行的结果依旧是 Promise 对象// 还发现， then 内部的 return 是下一个 then 的形参 Promise.prototype.catch() catch 与 then 一样，返回值是 新的 Promise 对象我们知道， then 的第二个函数参数，可以看做捕获错误的方法我们还知道 then 可以链式调用试想一下，当链式调用多个 then 方法时，难道要写多个错误处理方法，不会显得臃肿么那么， catch 方法就是为此而生所以， catch 方法可以充当 then 方法的第二个函数参数，并且建议使用 catch 方法请看下面的详细分析 123456789101112131415161718192021222324252627282930313233343536373839new Promise(resolve =&gt; &#123; resolve(msg) // 抛出错误：msg is not defined &#125;) .then(_data =&gt; console.log(_data)) // 不会执行，因为 then 之前的错误没有捕获 .catch(_error =&gt; console.log(_error)) // 捕获错误：msg is not defined// 上面的 then 方法未执行，是因为错误没有被捕获，如果把 catch 放在 then 之前（如下代码）new Promise(resolve =&gt; &#123; resolve(msg) // 抛出错误：msg is not defined &#125;) .catch(_error =&gt; console.log(_error)) // 捕获错误：msg is not defined 。如果没有错误，直接跳过 catch 方法 .then(_data =&gt; console.log(_data)) // 执行，打印：undefined// catch 可以还可以捕获 then 方法中的错误（如下代码）new Promise(resolve =&gt; &#123; resolve('OK') &#125;) .then(_data =&gt; &#123; var test = unnamed // 抛出错误：unnamed is not defined &#125;) .catch(_error =&gt; console.log(_error)) // 捕获错误：unnamed is not defined// catch 内部依旧可以抛出错误，但是需要另外一个 catch 来监听了（如下代码）new Promise(resolve =&gt; &#123; resolve('OK') &#125;) .then(_data =&gt; &#123; console.log(_data) // 执行，打印：Ok var test = unnamed_one // 抛出错误：unnamed_one is not defined &#125;) .catch(_error =&gt; &#123; console.log(_error) // 捕获错误：unnamed_one is not defined var test = unnamed_two // 抛出错误：unnamed is not defined &#125;) .catch(_error =&gt; console.log(_error)) // 捕获错误：unnamed is not defined 看过上面的代码分析后，至少可以总结出：Promise 错误具有冒泡性质，错误会不断的向后传递，直到 .catch() 捕获如果 then 方法遇到没有捕获的储物，就不会执行 还有：catch 方法是then(null, rejection)的别名（如下代码） 123456789Promise.resolve() .then(_success =&gt; console.log(_success)) .catch(_error =&gt; console.log(_error))// 等同于Promise.resolve() .then(_success =&gt; console.log(_success)) .then(null, _error =&gt; console.log(_error))// 建议第一种方式，实现更简洁，代码更具语义性 注意：catch 不能捕获异步错误，请看如下代码： 12345678910111213141516171819202122232425262728let _promise1 = () =&gt; new Promise(() =&gt; &#123; throw new TypeError('I am a error') // 抛出错误 &#125;), _promise2 = () =&gt; new Promise(() =&gt; &#123; setTimeout(() =&gt; &#123; throw new TypeError('I am a error') // 抛出错误 &#125;, 0) &#125;), _promise3 = () =&gt; new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; reject('I am a error') // 主动执行错误情况 &#125;, 0) &#125;)// 普通错误抛出情况_promise1() .catch(_error =&gt; console.log(_error)) // 捕获错误，打印：I am a error// 异步错误抛出情况_promise2() .catch(_error =&gt; console.log(_error)) // 未捕获错误，执行环境报错// 异步 reject 情况_promise3() .catch(_error =&gt; console.log(_error)) // 执行错误，打印：I am a error// 所以：在 Promise 中，你不明确 throw 的正确方法，那么请使用 reject// 注意你的代码，不要出现意料之外的错误抛出，所有可能的错误都请用 reject 拒绝 Promise 的静态方法Promise.resolve(param) 1234567891011121314151617// 1，如果_param 为空，直接返回状态为『Resolved』的 Promise 实例// 2，如果_param 为 Promise 实例，直接原封不动的返回。即使原来的实例是「rejected」状态，也是原封不动的返回// 3，如果_param 为「thenable」对象，线将「thenable」对象转为 Promise 对象，然后就立即执行「thenable」对象的 then 方法// 「thenable」对象指的是具有 then 方法的对象，比如：let thenable = &#123; then: function(resolve, reject) &#123; resolve('I was resolved') &#125;&#125;var _promise = Promise.resolve(thenable)_promise.then(_data =&gt; console.log(_data)) // 打印：I was resolved// 4，param 不是「thenable」对象，或根本就不是对象var _promise = Promise.resolve('I am promise')_promise.then(_data =&gt; console.log(_data)) // 打印：I am promise Promise.reject() 和Promise.resolve()一样，只是返回的 Promise 实例的状态为rejected即使传入的参数是状态为 resolved 的 Promise 实例，返回的实例状态依旧是rejected 12345var _promise = Promise.reject('error')// 等同于// var _promise = new Promise((resolve, reject) =&gt; reject('I am error'))_promise.catch(_errpr =&gt; console.log('I am error')) // 打印：I am error Promise.all() all方法可以接受一个具有 Iterator 接口的对象（一般为数组），且返回的每个成员都是 Promise 实例all方法依旧返回一个新的 Promise 实例当参数的所有 Promise 实例都为resolved时， all 方法才返回resolved，反之则然 12345678910111213141516171819202122232425// 定义一个获取 Promise 实例的方法，根据传入参数确定返回实例的状态let _promise = _value =&gt; new Promise((resolve, reject) =&gt; &#123; setTimeout(_value =&gt; &#123; // 如果传入的参数以「resolve」开头，这返回状态为 resolve 的实例，反之则然 if (/^resolve/.test(_value)) &#123; resolve(_value) return &#125; reject(_value) &#125;, 1000, _value)&#125;)// all 参数成员状态都为 resolve ，返回实例状态也为 resolve// 且返回实例的回调参数是一个数组，数组元素是每一个参数实例的回调参数Promise .all([_promise('resolveOne'), _promise('resolveTwo')]) .then(_success =&gt; console.log(_success)) // 因为成员状态都为 resolve ，打印：["resolveOne", "resolveTwo"] .catch(_error =&gt; console.log(_error)) // 因为成员状态都为 resolve ，所以不执行// all 参数成员状态至少有一个 reject// 且返回实例的回调参数是第一个状态为 reject 的参数实例的回调参数Promise .all([_promise('resolveOne'), _promise('rejectOne')]) .then(_success =&gt; console.log(_success)) // 因为成员状态有一个 reject ，所以不执行 .catch(_error =&gt; console.log(_error)) // 因为成员状态有一个 reject ，打印：rejectOne Promise.race() race 方法和 all 方法用法一模一样，只是返回值有点差别从字面理解就能看出来， race 是比赛的意思说明参数实例谁先状态发送改变就调用谁 123456789101112// 定义一个获取 Promise 实例的方法，根据传入的第一个参数确定改变状态的快慢let _promise = (_time, _value) =&gt; new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; resolve(_value), _time)&#125;)// race 参数成员状态都为 resolve ，返回实例状态也为 resolve// 且返回实例的回调参数是一个数组，数组元素是每一个参数实例的回调参数Promise .race([_promise(2000, 'resolveSlow'), _promise(1000, 'resolveFast')]) .then(_success =&gt; console.log(_success)) // 第二个参数实例更快改变状态，打印：resolveFast// 可以看出，第二个参数实例用时更快，先自行它的回调方法，且另一个参数实例回调方法不再执行 Promise 总结Promise 可以看做是回调函数的改进方案，解决了 callback 的回调深渊使用 then 可以让异步操作更加清晰明了不过原来的异步任务被 Promise 包装后，不管什么操作，放眼望去都是 then ，这导致原来的语义变得不那么清楚]]></content>
      <tags>
        <tag>JS</tag>
        <tag>promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime 配置 & 教程]]></title>
    <url>%2F2016%2F04%2F27%2Fsublime%2F</url>
    <content type="text"><![CDATA[主要是真对前端开发友好的配置 下载 sublime官网下载 安装 Package Control快捷键「ctrl + `」，然后输入对应的 Python code，详情见 官网链接。 安装需要的 Package 快捷键 command + shift + P 输入 Install Package 回车，等待一会儿 输入想要安装的 Package 安利一些前端合适的 Package「具体 Package 的作用可以自己 google」： Babel CSScomb DocBlockr Emmet HTML-CSS-JS Prettify LESS Meterial Theme Sass SideBarEnhancements TrailingSpaces 卸载 Package 快捷键 command + shift + P 输入 Remove Package 输入想要卸载的 Package，回车 配置 sublime 参数快捷键 command + shift + P，输入 Settings，回车；或者直接输入快捷键 「command + `」。然后在弹出的窗口右侧输入配置。 以下为建议配置「对应的含义请自行 google」： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&#123; "always_show_minimap_viewport": true, "caret_style": "phase", "css": &#123; "indent_char": " ", "indent_size": 2 &#125;, "enable_tab_scrolling": false, "folder_exclude_patterns": [ ".svn", ".git", "node_modules", ".hg", "CVS" ], "font_options": [ "gray_antialias", "subpixel_antialias" ], "font_size": 14, "highlight_line": true, "highlight_modified_tabs": true, "html": &#123; "indent_char": " ", "indent_size": 2 &#125;, "ignored_packages": [ "Vintage" ], "indent_guide_options": [ "draw_normal", "draw_active" ], "js": &#123; "indent_char": " ", "indent_size": 2 &#125;, "line_padding_bottom": 3, "line_padding_top": 3, "overlay_scroll_bars": "enabled", "rulers": [ 80 ], "scroll_past_end": true, "show_full_path": true, "tab_completion": true, "tab_size": 2, "translate_tabs_to_spaces": true, "vintage_start_in_command_mode": true, "word_wrap": true&#125; 配置 sublime 主题个人审美不同，我喜欢：Material ThemeMaterial Theme 的 github 首页 有安装教程安装成功后，在 sublime 参数里面添加如下配置 12345678&#123; "theme": "Material-Theme.sublime-theme", "color_scheme": "Packages/Material Theme/schemes/Material-Theme.tmTheme", "material_theme_compact_sidebar": true, "material_theme_contrast_mode": true, "material_theme_small_tab": true, "material_theme_tabs_autowidth": true,&#125; 「除了第一行 &quot;theme&quot;: &quot;Material-Theme.sublime-theme&quot; 是必须的配置以外，其他的都是自定义配置，可以根据 官方配置表 选择」]]></content>
      <tags>
        <tag>教程</tag>
        <tag>sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[baseCss]]></title>
    <url>%2F2015%2F05%2F27%2FbaseCss%2F</url>
    <content type="text"><![CDATA[前端开发中如果不是 UI 特别要求，颜色值采用 web 安全色最佳，像素以偶数最佳移动端开发，量度可以尝试 rem 为单位「什么是 rem，请自行 Google」使用 rem 为量度单位时，浏览器会是基于 html 节点而不是 body 节点计算大小 意义统一不同浏览器差异、团队开发起始标准；弥补浏览器的「缺点」 代码解释123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212/** * base.css - 航洋无声 * mail - hangyangws@foxmail.com * weibo - http://weibo.com/512jj */html &#123; /*标准字体大小设置 14 像素「rem 参照对象」*/ font-size: 14px; /*滚动事件发生在 html 元素上；JS 中可以监听 html 的滚动*/ overflow-y: auto; /*让 html 和浏览器窗口高度一致*/ height: 100%; /*少数浏览器默认背景色为浅灰色，所以设置默认背景颜色为纯白*/ background-color: #fff;&#125;html,body &#123; /*body 宽度大 html 度时，某些浏览器会出现内部滚动条；所以设置「html、body」宽度相同且「overflow-x: hidden」*/ overflow-x: hidden; width: 100%; /*取消部分浏览器点击有阴影*/ -webkit-tap-highlight-color: rgba(0, 0, 0, 0); /*优化移动端滚动事件*/ -webkit-overflow-scrolling: touch; overflow-scrolling: touch;&#125;body &#123; /*设置基本字体配置*/ font: 1rem 'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft Yahei', Arial, sans-serif; /*让绝对定位元素，根据 body 定位*/ position: relative; /*设置网页基本字体颜色为浅灰色*/ color: #666; /*使字体渲染更顺滑*/ -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-rendering: optimizeLegibility;&#125;/** * 移除常用标签的浏览器默认的「margin、padding」 * pre、code、legend、fieldset、blockquote … 等标签不是很常用，所以就不一一列举，如果项目中使用到，可以自己单独写 */body,p,h1,h2,h3,h4,h5,h6,dl,dd,ul,ol,th,td,button,figure,input,textarea,form &#123; margin: 0; padding: 0;&#125;/** * 不同浏览器的 input、select、textarea 的盒子模型宽度计算方式不同，统一为最常见的 content-box */input,select,textarea &#123; -webkit-box-sizing: content-box; -moz-box-sizing: content-box; box-sizing: content-box;&#125;table &#123; /*table 相邻单元格的边框间的距离设置为 0*/ border-spacing: 0; /*默认情况下给 tr 设置 border 没有效果，如果 table 设置了边框为合并模式：「border-collapse: collapse;」就可以了*/ border-collapse: collapse;&#125;/** * 移除浏览器部分元素的默认边框 * acronym、fieldset … 等其他标签不是很常用，就不会一一列举；如果项目中用到，可以自己单独写 */img,input,button,textarea &#123; border: none; -webkit-appearance: none;&#125;input &#123; /*由于 input 默认不继承父元素的居中样式，所以设置：「text-align: inherit」*/ text-align: inherit;&#125;textarea &#123; /*textarea 默认不可以放缩*/ resize: none;&#125;/** * 由于以下元素的部分属性没有继承父节点样式，所以声明这些元素的这些属性为父元素的属性 * 取消这些元素 `outline` 样式 */a,h1,h2,h3,h4,h5,h6,input,select,button,option,textarea,optgroup &#123; font-family: inherit; font-size: inherit; font-weight: inherit; font-style: inherit; line-height: inherit; color: inherit; outline: none;&#125;/** * 取消超链接元素的默认文字装饰 * 另外 del、ins 标签的中划线、下划线还是挺好的，就不去掉 */a &#123; text-decoration: none;&#125;ol,ul &#123; /*开发中 UI 设计的列表都是和原生的样式差太多，所以直接给取消 ol，ul 默认列表样式*/ list-style: none;&#125;button,input[type='submit'],input[type='button'] &#123; /*鼠标经过是「小手」形状表示可点击*/ cursor: pointer;&#125;input::-moz-focus-inner &#123; /*取消火狐浏览器部分版本 input 聚焦时默认的「padding、border」*/ padding: 0; border: 0;&#125;/*取消部分浏览器数字输入控件的操作按钮*/input[type='number'] &#123; -moz-appearance: textfield;&#125;input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button &#123; margin: 0; -webkit-appearance: none;&#125;/*输入控件 placeholder 色设置 #999*/input::-webkit-input-placeholder,textarea::-webkit-input-placeholder &#123; color: #999;&#125;input:-moz-placeholder,textarea:-moz-placeholder &#123; color: #999;&#125;input::-moz-placeholder,textarea::-moz-placeholder &#123; color: #999;&#125;input:-ms-input-placeholder,textarea:-ms-input-placeholder &#123; color: #999;&#125;template &#123; /*由于部分浏览 template 会显示出来，所以要隐*/ display: none;&#125; 另外附上 常用原子类 感谢阅读]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于我]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[一个普通的人想过不一样的生活一名前端工程师是个铲屎官 喜欢音乐，会点吉他和口琴热爱徒步和旅行 —— vLog 工作 2016 - 亚信 2017 - 知乎 2018 - 淘宝 2019 - ThoughtWorks 联系 email：&#x68;&#97;&#110;&#103;&#x79;&#x61;&#110;&#x67;&#119;&#x73;&#x40;&#103;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#111;&#x6d; 知乎：https://www.zhihu.com/people/hangyangws/activities github： https://github.com/hangyangws bilibili：https://space.bilibili.com/393696047 weibo：https://weibo.com/512jj]]></content>
  </entry>
  <entry>
    <title><![CDATA[gallery]]></title>
    <url>%2Fgallery%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[标签]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
